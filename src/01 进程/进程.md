# 随记

1.用户态与内核态之间的转换叫：模式切换，通过**中断**完成（在进程切换会讲）

# 进程的定义

1.程序（Program）本质是存在磁盘上的指令，即可执行文件。如Java文件或Class文件，它本质是一份文件，只不过包含或者可以间接生成为计算机指令罢了。程序必须是被动启动的，作为文件它自身不会启动。

2.程序被启动后，被加载到内存中，在CPU内执行程序的指令，就变成了进程（Process），可以理解为：正在进行的程序。当程序的所有指令都被执行完成后，这个进程就结束了。

3.同时，进程会拥有一个**程序计数器**（Program Counter），用来指向下一条要执行的指令。



# 回顾一下程序计数器 

它是一个CPU中的寄存器（寄存器的其中一个类型），存放的信息是：下一条要执行的指令的内存地址。通常CPU在取完一条指令后会将计数器的值+1（PC=PC+1），即下一条要执行指令的地址。



# 进程在内存的分配

总的来说，一个进程在进程的分配可以分成四个部分：text、data、stack、heap。

![daa5d48c13971a9ba24c7ae18ddf027](https://user-images.githubusercontent.com/48977889/143726179-e22ae74f-8c57-4446-ba06-97c615df6352.jpg)

text：存储程序最终编译转换成的二进制代码 ，这块区域是read only的。程序第一个要执行的指令会放在pc寄存器里，第一条要执行的指令往往是程序的入口，在编程语言里这个入口一般为主函数，如Java的main、C的main、Go的main

data：全局与静态变量。

stack：存放局部变量的地址、函数的返回地址（即函数本身）。

heap：运行时的动态内存分配（即局部变量真正存储的地方）。



# 进程的内存生命周期

先看以下代码

```c
int global = 100;

void f(int x,int y){
    int* p = malloc(100);
    return;
}

void g(int a){
    f(a, a+1);
    return;
}

int main(){
    static int i = 10;
    g(i);
    return 0;
}
```



当以上C代码被编译运行时，编译成的二进制代码会被写入该**进程内存**的text区。同时第一个指令（main入口）会被写入PC寄存器内，CPU开始执行。

1.主函数开始执行时，会将函数返回地址写入stack内（void也可以理解为一个返回值）。

2.在执行主函数时，发现int global = 100;与static int i = 10;于是在data区创建这两个变量。

3.接下来发现要执行g函数，于是将g函数的返回地址写入stack内（注意stack本质是一个栈），此时main函数暂停执行，跳转到执行g函数。**注意跳转的操作其实在二进制指令里就确定好了，也就是说控制CPU暂停main函数执行，转去执行g函数在编译后就确定了**。

4.执行g函数发现还有f函数，同理将f函数返回值写入stack内，同时跳转到执行f函数。

5.发现f函数在内存生成了一个p变量int* p = malloc(100); 此时会在heap区内生成100byte大小的空间，**这块空间的地址会赋给stack区内的p指针**（此刻对应上：引用存栈、变量存堆的说法）。

6.f函数return，return会将f在stack存的内容给清掉（出栈）。

7.g函数return，g在stack出栈。

8.main函数return，main在stack出栈，主函数出栈会回收静态资源，即将data区、text区的数据清掉，最终程序结束。

9.注意5.生成的p变量还在heap里，程序回收资源只会回收引用，并不会主动回收实际存储在内存的变量（c语言），必须在编译器确定回收。不过一些有GC功能的语言会自动回收无用的heap空间，不同语言确定这块空间是否“无用”也有不同的策略，如Java、Go。此时对于程序员来说不用关心堆内存的整理，可以完全交给编程语言。



# 进程状态

进程状态是用来描述进程执行期间的状态，有三个：运行态（Running） 就绪态（Ready） 等待态（Waiting），等待态也称阻塞态。

运行态：已经在被CPU调度运行中了。

就绪态：进程已经可以运行了，但还没被CPU调度，直到抢到CPU时间片，才会变成运行态。

等待态：进程在等待一件事件的完成，如网络IO、文件IO，需要等事件结束后自身才能运行。**当进程进入等待态后，释放时间片，事件返回后转为就绪态**：即  运行态 → 释放CPU时间片 → 等待态 → IO事件阻塞 → IO事件完成 → 就绪态。 

## 进程如何放弃时间片

进程只有在运行态会放弃CPU，一般有两种情况：主动放弃、被动放弃。

主动放弃：进程基于二进制指令的决策而放弃占用的时间片，如进程需要使用IO设备，等待IO设备返回结果时，会主动放弃，此时进程进入等待态。又或者异常发生，如错误代码导致程序结束，此时进程会进入终止状态，同时让出时间片。

被动放弃：进程的时间片用完了，进入就绪状态，开始和其他进程**抢占**CPU时间片。

![b761e4f9fe610cfe4f8b18157ede3ce](https://user-images.githubusercontent.com/48977889/143726569-102b4884-1bcd-4cee-98fd-aa0e27db0b21.jpg) 

