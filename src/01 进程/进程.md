# 随记

1.用户态与内核态之间的转换叫：模式切换，通过**中断**完成（在进程切换会讲）

# 进程的定义

1.程序（Program）本质是存在磁盘上的指令，即可执行文件。如Java文件或Class文件，它本质是一份文件，只不过包含或者可以间接生成为计算机指令罢了。程序必须是被动启动的，作为文件它自身不会启动。

2.程序被启动后，被加载到内存中，在CPU内执行程序的指令，就变成了进程（Process），可以理解为：正在进行的程序。当程序的所有指令都被执行完成后，这个进程就结束了。

3.同时，进程会拥有一个**程序计数器**（Program Counter），用来指向下一条要执行的指令。



# 回顾一下程序计数器 

它是一个CPU中的寄存器（寄存器的其中一个类型），存放的信息是：下一条要执行的指令的内存地址。通常CPU在取完一条指令后会将计数器的值+1（PC=PC+1），即下一条要执行指令的地址。



# 进程在内存的分配

总的来说，一个进程在进程的分配可以分成四个部分：text、data、stack、heap。

![daa5d48c13971a9ba24c7ae18ddf027](https://user-images.githubusercontent.com/48977889/143726179-e22ae74f-8c57-4446-ba06-97c615df6352.jpg)

text：存储程序最终编译转换成的二进制代码 ，这块区域是read only的。程序第一个要执行的指令会放在pc寄存器里，第一条要执行的指令往往是程序的入口，在编程语言里这个入口一般为主函数，如Java的main、C的main、Go的main

data：全局与静态变量。

stack：存放局部变量的地址、函数的返回地址（即函数本身）。

heap：运行时的动态内存分配（即局部变量真正存储的地方）。



# 进程的内存生命周期

先看以下代码

```c
int global = 100;

void f(int x,int y){
    int* p = malloc(100);
    return;
}

void g(int a){
    f(a, a+1);
    return;
}

int main(){
    static int i = 10;
    g(i);
    return 0;
}
```



当以上C代码被编译运行时，编译成的二进制代码会被写入该**进程内存**的text区。同时第一个指令（main入口）会被写入PC寄存器内，CPU开始执行。

1.主函数开始执行时，会将函数返回地址写入stack内（void也可以理解为一个返回值）。

2.在执行主函数时，发现int global = 100;与static int i = 10;于是在data区创建这两个变量。

3.接下来发现要执行g函数，于是将g函数的返回地址写入stack内（注意stack本质是一个栈），此时main函数暂停执行，跳转到执行g函数。**注意跳转的操作其实在二进制指令里就确定好了，也就是说控制CPU暂停main函数执行，转去执行g函数在编译后就确定了**。

4.执行g函数发现还有f函数，同理将f函数返回值写入stack内，同时跳转到执行f函数。

5.发现f函数在内存生成了一个p变量int* p = malloc(100); 此时会在heap区内生成100byte大小的空间，**这块空间的地址会赋给stack区内的p指针**（此刻对应上：引用存栈、变量存堆的说法）。

6.f函数return，return会将f在stack存的内容给清掉（出栈）。

7.g函数return，g在stack出栈。

8.main函数return，main在stack出栈，主函数出栈会回收静态资源，即将data区、text区的数据清掉，最终程序结束。

9.注意5.生成的p变量还在heap里，程序回收资源只会回收引用，并不会主动回收实际存储在内存的变量（c语言），必须在编译器确定回收。不过一些有GC功能的语言会自动回收无用的heap空间，不同语言确定这块空间是否“无用”也有不同的策略，如Java、Go。此时对于程序员来说不用关心堆内存的整理，可以完全交给编程语言。



# 进程状态

进程状态是用来描述进程执行期间的状态，有三个：运行态（Running） 就绪态（Ready） 等待态（Waiting），等待态也称阻塞态。

运行态：已经在被CPU调度运行中了。

就绪态：进程已经可以运行了，但还没被CPU调度，直到抢到CPU时间片，才会变成运行态。

等待态：进程在等待一件事件的完成，如网络IO、文件IO，需要等事件结束后自身才能运行。**当进程进入等待态后，释放时间片，事件返回后转为就绪态**：即  运行态 → 释放CPU时间片 → 等待态 → IO事件阻塞 → IO事件完成 → 就绪态。 

## 进程如何放弃时间片

进程只有在运行态会放弃CPU，一般有两种情况：主动放弃、被动放弃。

主动放弃：进程基于二进制指令的决策而放弃占用的时间片，如进程需要使用IO设备，等待IO设备返回结果时，会主动放弃，此时进程进入等待态。又或者异常发生，如错误代码导致程序结束，此时进程会进入终止状态，同时让出时间片。

被动放弃：进程的时间片用完了，进入就绪状态，开始和其他进程**抢占**CPU时间片。

![b761e4f9fe610cfe4f8b18157ede3ce](https://user-images.githubusercontent.com/48977889/143726569-102b4884-1bcd-4cee-98fd-aa0e27db0b21.jpg) 



# 进程切换

## 中断

用户态 → 内核态 是通过**中断**完成的，中断有外中断、内中断两种模式。

外中断：除了CPU以外，其他硬件发起的中断，如时间片用尽中断、键盘中断、鼠标中断，属于被动中断。

内中断：在执行指令过程中发生的中断，如指令异常、错误操作、系统调用（system call），属于主动中断。

## 中断处理过程

![bbca22f0ca5513eaef6c7d34c962328](https://user-images.githubusercontent.com/48977889/145150580-ae6c3f05-e02e-4cd1-afc9-e6fb7db06104.png)

1.发生中断后，CPU保存进程A的上下文（IR、PC等信息）到哪里？

2.CPU陷入内核态，根据中断类型（内外中断）来处理对应的逻辑。

3.处理完成后，恢复进程A保存好的上下文，继续执行，此时CPU转为用户态。

4.用户态和内核态的相互转化，也可称为Trap。

## 特权指令和非特权指令

特权指令：CPU只能在内核态运行的指令，如IO指令、进程切换。

非特权指令：CPU只能在用户态运行的指令，如执行程序运算代码。

CPU如何确定指令类型？通过双模式-dual mode确定，通过一个bit位来确认（TODO）

## 模式切换

内核态 → 用户态是通过Load PSW指令完成的。当中断发生的时候，CPU立刻转变为内核态，最终执行PSW指令切换回用户态。

## 进程切换过程

进程切换过程需要CPU在内核态才能完成，而用户态进入内核态的条件是：中断

进程为什么会被切换：发生中断，如时间片耗尽，发生外中断（最典型）；如发生系统调用，比如等待数据库返回数据，总不能一直让进程占用着时间片去等吧，所以进入等待状态，好让CPU调度其他线程，提升CPU的执行效率。

这里以：CPU执行进程A，切换到进程B执行为例

1.进程A发生中断。

2.保存进程A的上下文。

3.修改进程A的控制信息，如状态等，这部分信息在PCB里被描述（TODO）。

4.将被中断的进程加入相应的状态队列，如等待队列、就绪队列，队列的节点其实是PCB。

5.调度进程B，恢复进程B的上下文信息到CPU内，执行进程B之后的指令，CPU切换回用户态。

## PCB

Process Control Block，进程控制块，每个进程对应一个PCB。操作系统在管理进程时，通过PCB来确认进程的信息。

![d77b4827952e264be63b8430f645493](https://user-images.githubusercontent.com/48977889/145150591-a4c24448-be74-471e-9b7c-2db893522ca2.jpg![2dbbb32296d013e8445f5d5216909c1](https://user-images.githubusercontent.com/48977889/145151440-96e97cb5-2ebb-4d3f-b729-90e2f688b50d.jpg)

PCB拥有以下六块区域

1.进程状态：该进程是运行态、就绪态、还是等待态

2.进程编号：描述进程唯一的id，即linux中的pid

3.pc：进程下一条要执行的指令

4.寄存器值（TODO）

5.进程在内存的管理信息（TODO）

6.这个进程打开的文件

进程在内存的分配除了stack、heap、data、text外，**还有进程本身的PCB，这一整个部分被称为进程的上下文**，除了PCB以外的分配区域为**运行实体**。

# 进程管理

## 进程在物理内存的分配

![b7df1aabaec90a91a84a58f03b491cb](https://user-images.githubusercontent.com/48977889/145152677-bdafe093-313a-46d9-9ee7-861fc793939a.jpg)

1.进程在物理内存的分配不是连续的，首先连续分配内存会导致内存管理困难。

2.如何在物理内存上寻址到进程对应的分配区域，是通过OS的动态内存分配实现，后面会说（TODO）。

## 进程队列

![55b5046ad96e5607b9f214cfd8563ff](https://user-images.githubusercontent.com/48977889/145153562-4d2bf8cf-7767-4a88-acd3-d09de98e22d3.jpg)

进程是通过队列进行管理的，有就绪队列和等待队列两种，就绪队列一般只有一条，而等待队列会根据不同的等待设备（如网络IO、磁盘读写）区分多条队列。进程队列的节点是PCB，因为PCB作为描述进程信息的结构，可以获取到进程的所有信息来调度，且体量轻，方便管理。

## 进程调度

进程在生命周期当中，会在各个进程队列里迁移、调度，这个操作是由OS的调度器（scheduler）执行。

![image-20211208133632029](C:\Users\koujy\AppData\Roaming\Typora\typora-user-images\image-20211208133632029.png)

进程在初始化阶段，会进入就绪队列，被CPU执行，以下四种情况发生，会被调度器调度

1.系统调用发出IO请求，此时调度器会将PCB放入等待队列，当IO请求获得响应后，调度器将PCB放回就绪队列。属于主动调度

2.时间片过期，此时调度器会将PCB直接插入就绪队列。属于被动调度

3.派生子进程，子进程初始化成功后，调度器将PCB插入就绪队列，属于主动调度。

4.发生外中断，调度器将PCB插入就绪队列，属于被动调度。