# 长程调度与短程调度

长程调度：将硬盘中的程序调度到内存内形成进程。

短程调度（**CPU调度**）：讲内存中的进程调度到CPU上执行、或者将执行中的进程变为等待、就绪态。

# 基本概念

当多个进程并发存在于内存，运行在CPU时，其中一个进程暂不使用CPU，**CPU调度**通过调度程序使另一个进程占用CPU。简单来说，**CPU调度引发进程切换/线程切换**。



# 长进程与短进程

长进程：CPU密集程序，IO比较少，更多是在利用CPU运算。如计算八皇后的解，普通数学运算。

短进程：IO密集程序，CPU运算比较少，更多是利用IO时间达成程序目的。如后端程序，更多是利用数据库、缓存等IO操作。



# 抢占调度与非抢占调度

非抢占调度：除非自己的指令执行完；变为终止状态、或者发起系统调用，否则都不会让出CPU时间片。

抢占调度：与非抢占调度相反。

# CPU调度策略

**以下算法只是理论，实际运用会根据操作系统的不同存在实现差异。**

## FCFS（非抢占式调度算法）

先来先服务策略：根据PCB队列的插入顺序来决定调度顺序，先插入队的先调度。前面的进程未执行完、或未发起系统调用，就会一直占用CPU。这是最简单粗暴的调度方式，缺点很明显，如果作业时间很长的进程在队尾，那么对后面的进程不公平。

## ROUND ROBIN（抢占式调度算法）

时间片轮转策略：每个进程获取**相同的CPU时间（CPU时间片）**，只要**时间片到达或执行完成**，进程就会被CPU调度到就绪队列尾部。假设就绪队列长度为n，每个进程能够分配到的时间片是q，那么进程的等待时间不会超过(n-1)q。

然而RR策略的时间片取值太小，进程切换开销会增大；取值太大切换次数会变少，使其接近于FCFS，所以一般时间片取值10ms-100ms（进程切换的开销时间大概是0.1ms - 1ms）。

## SJF（非抢占式）/SRTF（抢占式调度算法）

最短作业优先策略：下一次调度**总是**选择队列中CPU时间最短的进程进行调度。该算法在理论上被证明是**最优解**，但需要提前预测进程所需要的CPU时间，这部分实现会比较复杂。如果算法设计的不够好，会导致长进程长时间无法获取CPU（饥饿现象）。**由于现阶段无法准确算出进程需要的CPU时间，所以该算法更多停留在理论上**。

## PRIORITY（抢占、非抢占都可）

优先级调度策略：通过数字标识进程的优先级，下一次调度**总是**选择优先级最高的进程，SJF是一个特殊的PRIORITY，只不过它的优先级是按进程所需时间片排序。当进程优先级相同时，可以采用FCFS策略。

PRIORITY的非抢占式调度：按优先级排序执行。

PRIORITY的抢占式调度：如果执行进程的过程中，发现有更高优先级的进程出现，则让出CPU时间片给更高优先级的进程。

如何定义优先级：

1.静态优先级：进程执行前**根据特定策略**定下优先级，并且保持不变。这种策略可能会出现饥饿现象（低优先级一直拿不到时间片）。

2.动态优先级：根据进程CPU占用时间、等待时间动态更改进程优先级。如占用时间越长，则逐渐降低它的优先级；如等待时间越长，则逐渐提升它的优先级。

3.静态+动态优先级结合。

现代操作系统大多使用动静结合。