# 回顾进程

讲线程之前，首先说一下进程切换的开销。

![6392e7395f84c1f8c717fe73f4aed22](https://user-images.githubusercontent.com/48977889/145759282-ec34875e-3181-4b38-8f49-2512f0408ef6.jpg)

可以看到，当OS内有多个进程的话，更多的时间是花在不同进程之间的上下文切换，而不是执行程序的代码。直接以“进程”作为OS的调度单位开销会很大，因此需要一个层级比进程更小的调度单位，即“线程”。

# 线程与进程

![1ccc3b9f0cdce441f277bd81d1fdf9a](https://user-images.githubusercontent.com/48977889/145759292-a9aeb5e8-a446-44fb-8823-aac8e7e628ad.jpg)

 一个进程默认只有一个执行流，即线程。单线程拥有该进程的所有资源，可以将这个线程理解为进程本身。若进程派生了多个线程，多个线程之间共享同一个父进程的代码、data区、操作系统资源（如文件、信号），**每个线程都有它自己的PC、registers区（存放执行时各种CPU寄存器的值）、stack区、线程ID**。

线程会作为一个调度单位，被CPU调度，它与进程一样既有并发调度也有并行调度，具体要看实际的调度场景。线程的调度开销会比进程小（TODO 在线程切换时讲），同等数量下，多线程会有更多的时间去执行程序代码。

# 线程模型

线程模型有三种：M:1、1:1、M:N，目前主流的操作系统已弃用M:1、M:N、基本上都是用1:1

说线程模型前，先抛出两个概念：ULT、KLT

![e480ca6d5a490e5f10c950a2de7f10a](https://user-images.githubusercontent.com/48977889/145936028-82833d8f-9c62-4ca1-83a3-4915320ef517.jpg)

ULT：用户级线程，只能运行用户态的指令（非特权指令）。

KLT：内核级线程，只能运行内核态的指令（特权指令）。

**ULT必须和一个KLT绑定，才能在CPU上运行，也就是说：占用CPU时间片的只有KLT**。ULT和KLT的绑定关系即**线程模型**

## M:1

![image-20211214131721342](C:\Users\koujy\AppData\Roaming\Typora\typora-user-images\image-20211214131721342.png)

多个ULT对应一个KLT，用户态的角度看是多线程并发执行，实际上同一时刻只有1条ULT运行。

## 1:1

![image-20211214131805867](C:\Users\koujy\AppData\Roaming\Typora\typora-user-images\image-20211214131805867.png)

一个ULT对应一个KLT，当KLT不足时需要创建KLT以满足1:1的需求，同一时刻有CPU核数相同的KLT运行。随着用户级线程的创建、销毁，KLT也要随之创建、销毁，这就增大了内核开销。**Java在语言层面兼容这种设计模型**。

## M：N

![image-20211214132021071](C:\Users\koujy\AppData\Roaming\Typora\typora-user-images\image-20211214132021071.png)

多个ULT对应多个KLT，具体ULT对应哪个KLT需要一个**调度器**完成，同一时刻有CPU核数相同的KLT运行，**但KLT的数量会比较少，创建与销毁的频率比较低**。Golang在语言层面实现这种模式。

