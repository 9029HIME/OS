# 前提

从03开始，将作业成为**进程或线程**的执行过程。

# 作业与作业的关系

在用一个时间单位内，会有多个作业并发或并行地执行。当作业A与作业B之间的执行过程没有任何交互的地方（如该时间单位内对内存的同一块区域进行操作），则称作业A与作业B独立运行，如浏览器与视频播放器。反之则称作业A与作业B交互运行。交互有两种形式：竞争、协作。竞争指的是两个作业共同操作同一份内存区域（如同一个静态变量、全局变量），可能会引发数据不一致问题；协作指的是两个作业需要互相影响以达成程序目的，如作业A必须等待作业B结束后才能继续执行，可能会引发流程错误问题。

维持作业之间的交互运行正常，不引发问题的手段是：同步。同步有两种主流方式：互斥锁、信号量。

# 同步方式

## 互斥锁

互斥锁主要用来解决作业间竞争情况。临界区是作业要访问公共资源的代码区域，操作系统需要一个协议来**保证多个作业不对同时执行自己的临界区**。这个协议就是互斥锁。作业在进入临界区前需要获取互斥锁，如果拿不到就要**等待**，拿到锁才能进入临界区；结束临界区的代码后要释放锁。获取锁与释放锁的过程必须是**原子操作**。

原子操作（原语）：一旦占用CPU开始执行，无法被其他作业中断的指令，直到指令结束。如test_and_set()、compare_and_swap()。值得注意的是，这个定义适用于单核CPU；如果是多核CPU的情况下，原子操作会对内存设置**内存屏障**，确保在有效期内其他作业不会访问到同一块内存区域。

互斥锁是一种概念，落实到代码有很多种实现，以test_and_set()锁为例：

## test_and_set()锁

该锁主要运用test_and_set()这一条指令，指令内容如下

```c
bool test_and_set(bool *lock) { 
    bool old=*lock;  // 1
    *lock=false; 	// 2
    return old; 	// 3
} 
```

test_and_set()主要根据返回值来判断是否持锁，true=可以持有锁，反之则不行。如果作业A在//1获取了old = true，此时作业B也执行到//1，并且作业A还未执行//2，岂不是两个作业都认为true？如果是普通指令确实如此，但test_and_set()是原子指令，通过不被中断或内存屏障的方式可以保证只有一个作业执行完//1//2//3三个过程不会被打扰。

test_and_set()只是互斥锁这个思想的一个实现方式，互斥锁还有其他方式如cas等，OS本身也实现了互斥锁并封装好API给开发者调用，不同的编程语言也会在其API内实现特制的互斥锁（如ReentrantLock）。