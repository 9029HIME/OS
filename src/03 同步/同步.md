# 前提

从03开始，将作业称为**进程或线程**的执行过程。

# 作业与作业的关系

在用一个时间单位内，会有多个作业并发或并行地执行。当作业A与作业B之间的执行过程没有任何交互的地方（如该时间单位内对内存的同一块区域进行操作），则称作业A与作业B独立运行，如浏览器与视频播放器。反之则称作业A与作业B交互运行。交互有两种形式：竞争、协作。竞争指的是两个作业共同操作同一份内存区域（如同一个静态变量、全局变量），可能会引发数据不一致问题；协作指的是两个作业需要互相影响以达成程序目的，如作业A必须等待作业B结束后才能继续执行，可能会引发流程错误问题。

维持作业之间的交互运行正常，不引发问题的手段是：同步。同步有两种主流方式：互斥锁、信号量。

# 同步方式

## 互斥锁

互斥锁主要用来解决作业间竞争情况。临界区是作业要访问公共资源的代码区域，操作系统需要一个协议来**保证多个作业不对同时执行自己的临界区**。这个协议就是互斥锁。作业在进入临界区前需要获取互斥锁，如果拿不到就要**在循环里自旋等待**，拿到锁才能进入临界区；结束临界区的代码后要释放锁。获取锁与释放锁的过程必须是**原子操作**。

原子操作（原语）：一旦占用CPU开始执行，无法被其他作业中断的指令，直到指令结束。如test_and_set()、compare_and_swap()。值得注意的是，这个定义适用于单核CPU；如果是多核CPU的情况下，原子操作会对内存设置**内存屏障**，确保在有效期内其他作业不会访问到同一块内存区域。

互斥锁是一种概念，落实到代码有很多种实现，以test_and_set()锁为例：

### test_and_set()锁

该锁主要运用test_and_set()这一条指令，指令内容如下

```c
bool test_and_set(bool *lock) { 
    bool old=*lock;  // 1
    *lock=false; 	// 2
    return old; 	// 3
} 
```

test_and_set()主要根据返回值来判断是否持锁，true=可以持有锁，反之则不行。如果作业A在//1获取了old = true，此时作业B也执行到//1，并且作业A还未执行//2，岂不是两个作业都认为true？如果是普通指令确实如此，但test_and_set()是原子指令，通过不被中断或内存屏障的方式可以保证只有一个作业执行完//1//2//3三个过程不会被打扰。

test_and_set()只是互斥锁这个思想的一个实现方式，互斥锁还有其他方式如cas等，OS本身也实现了互斥锁并封装好API给开发者调用，不同的编程语言也会在其API内实现特制的互斥锁（如ReentrantLock）。

## 信号量

信号量的核心是对一个整型（Integer）进行原子加减操作（+1或-1），作业通过**访问信号量的整型是否符合规则**来判断是否有权进入临界区。作业对信号量的操作分为两步（**P和V都是原子操作**）：

P：查看信号量是否符合**规则**，符合则进入临界区，并对信号量进行减1

V：对信号量进行加1。

作业进入临界区前先执行P操作，如果不符合规则，阻塞作业，如果符合规则就进入临界区，对信号量原子加1。 退出临界区时对信号量进行V操作原子减1。具体的规则视信号量的作用而定，信号量既可以作互斥用，也可以作并行数量控制用。

信号量和互斥锁的区别在哪呢？首先使用互斥锁的情况下，当作业发现获取锁失败会选择自旋，自旋操作相当于空等待，浪费CPU时间片。而使用信号量的情况下，作业发现信号量不符合规则，会进入**信号量的任务队列**里，同时作业转为**等待态**；等占用信号量的作业完成后执行V操作后就会唤醒任务队列里的作业（需要看具体的唤醒调度策略，可以是FIFO，也可以是权重），使其转为就绪态，重新被CPU调度。也就是说：**信号量比如互斥锁不会自旋，更加充分地利用了CPU资源**。

### 信号量的类别

1.二值信号量

信号量的值只能为1或0，只能有一个作业占用信号量，通过二值信号量可以实现互斥锁的功能，**不过值得注意，比较多API将二值信号量也取名为Mutex**。

2.一般信号量

信号量的值可以为任意值，通常用于作业的并发数量控制，一般比较少用。

# 死锁

作业A占有同步资源X的同时，申请获取同步资源Y，进入等待状态；此时作业B占有同步资源Y，但作业B却申请获取同步资源X，作业B也因此进入等待状态，最终的情况是：作业A与作业B同时进入等待状态，如无外接干预的情况下将一直等待下去。这种情况叫“死锁”，死锁一般发生在多个作业竞争有限资源的条件下。

死锁与饥饿：饥饿进程指的是在CPU调度过程中由于调度算法的缺点导致某些进程很难被调度到CPU上运行，但饥饿现象仅代表“作业很难被调度执行，并非无法执行”；死锁代表“如无外接干扰，作业会一直等待同步资源”，**死锁会引起饥饿，但饥饿不会引起死锁**。

产生死锁的四大条件：

1.互斥使用：同一时刻，一个同步资源仅能被一个作业占用（排除一般信号量）。

2.不可剥夺：同步资源只能被作业主动释放，不可被其他作业强行占用。

3.占有并等待：作业在请求同步资源失败，陷入等待状态时，不会放弃手头上已有的同步资源。

4.循环等待：当前作业总是等待上一个占有资源的作业。

在**操作系统层面**要避免死锁，主流思想是：允许死锁产生，但OS需要检测并解决它们；于是有以下方案：

