# 内存本质（软件层面）

1.内存本质是一个很大的字节数组，每个字节都有它的地址（**物理地址**）。

2.CPU根据PC寄存器的值，从内存中获取下一条要执行指令。**这条指令可能会引发对内存的读写**。

3.一个指令执行周期：CPU从内存获取指令、指令被译码、指令被执行。

# Cache

即高速缓存，Cache是介于内存与CPU中间的一个中间设备，它的存取速度比内存快得多，但容量比内存小得多。要是CPU每次都直接操作内存效率会很慢很多。CPU在读取内存数据时优先读取缓存，如果缓存有则直接取缓存数据，反之则先从内存获取数据，然后备份数据到缓存，等下一次取相同数据时就可以直接从缓存拿了；这一步与Redis-数据库访问基本一致，但也面临着同样的问题：**当发生数据修改时如何保证缓存-内存一致性？ TODO**

现在主流的CPU通常有三级缓存：L1、L2、L3，级别越低越接近CPU，容量越小，速度越快。如下图（4核8线程）：

![caf1303be02a628e97cce6942e84ace](https://user-images.githubusercontent.com/48977889/147805276-fc51cb90-d5a6-45f5-b806-96be5aacf8ef.png)

每一个核心都有独立的L1、L2，多个核心共享一个L3，这也面临着**数据同步问题**。

# 内存分级

用户进程不能随意访问内存区域，也不能直接影响其他进程的内存区域，这条规则操作系统不直接干预，主要是通过两个硬件实现：基址寄存器、限长寄存器。这两个寄存器存在于CPU内，进程对内存的操作只能这两个寄存器限定的范围内。这两个寄存器的值只能通过特权指令设置，最终是通过CPU控制（也就是说有可能会被恶意植入）。

![6e439acaf68d47edf1f9bcea632f59a](https://user-images.githubusercontent.com/48977889/147805645-dfb20dd8-9dd5-4ac5-add8-bd1ce67fa204.png)

# 逻辑地址与物理地址的转换

