# 内存本质（软件层面）

1.内存本质是一个很大的字节数组，每个字节都有它的地址（**物理地址**）。

2.CPU根据PC寄存器的值，从内存中获取下一条要执行指令。**这条指令可能会引发对内存的读写**。

3.一个指令执行周期：CPU从内存获取指令、指令被译码、指令被执行。

# Cache

即高速缓存，Cache是介于内存与CPU中间的一个中间设备，它的存取速度比内存快得多，但容量比内存小得多。要是CPU每次都直接操作内存效率会很慢很多。CPU在读取内存数据时优先读取缓存，如果缓存有则直接取缓存数据，反之则先从内存获取数据，然后备份数据到缓存，等下一次取相同数据时就可以直接从缓存拿了；这一步与Redis-数据库访问基本一致，但也面临着同样的问题：**当发生数据修改时如何保证缓存-内存一致性？ TODO**

现在主流的CPU通常有三级缓存：L1、L2、L3，级别越低越接近CPU，容量越小，速度越快。如下图（4核8线程）：

![caf1303be02a628e97cce6942e84ace](https://user-images.githubusercontent.com/48977889/147805276-fc51cb90-d5a6-45f5-b806-96be5aacf8ef.png)

每一个核心都有独立的L1、L2，多个核心共享一个L3，这也面临着**数据同步问题**。

# 内存分级

用户进程不能随意访问内存区域，也不能直接影响其他进程的内存区域，这条规则操作系统不直接干预，主要是通过两个硬件实现：基址寄存器、限长寄存器。这两个寄存器存在于CPU内，进程对内存的操作只能这两个寄存器限定的范围内。这两个寄存器的值只能通过特权指令设置，最终是通过CPU控制（也就是说有可能会被恶意植入）。

![6e439acaf68d47edf1f9bcea632f59a](https://user-images.githubusercontent.com/48977889/147805645-dfb20dd8-9dd5-4ac5-add8-bd1ce67fa204.png)

# 逻辑地址与物理地址的转换 

现有的操作系统都是在进程运行时通过MMU进行地址转换的，MMU内有一个关键的寄存器：基址寄存器（重定位寄存器），地址转换是通过该寄存器完成的。

![5fd0396d8ff40ee1767581c82a02032](https://user-images.githubusercontent.com/48977889/147868905-d4d6b86e-058b-40dc-8134-81f28f067c15.png)

# 分段

进程在分段之前，首先讲一下内存的固定分区分配与动态分区分配：

固定分区分配：内存一开始就被固定分配了若干的分区，每个分区都有其固定的大小，**每个分区有且只能有一个进程**。为进程P分配内存时优先选择最符合进程所需内存的内存分区。

![20066b000618730814f4b0d9f22fdd4](https://user-images.githubusercontent.com/48977889/147876992-4de80ffc-4936-4121-8741-fef0acf89a3e.png)

动态分区分配：没有被分配出去的内存区域成为“孔（hole）”，为进程P分配内存时选择大小合适的孔给进程。初始状态时孔即内存大小，随着内存的分配与释放，孔的数量与大小会不断变化。对于孔的分配有三种策略：1.首次分配：即选择第一个能容纳进程所需内存大小的孔；2.最佳分配：选择一个大小与进程所需内存大小最接近的孔，3.最坏分配：选择最大的孔分配。

![5034b8973c68e9ee01dbdaffd1bb03b](https://user-images.githubusercontent.com/48977889/147876998-c7c650be-9b10-4297-b77b-37f2f6dfc984.png)

对于固定分区分配来说，内存碎片指的是分区内进程无法用到的内存区域（容量-分区 ＞ 容量-进程）。对于动态分区分配来说，内存碎片指的是	接下来的一段时间内由于太小而无法分配给进程的孔。目前主流用的是动态分区分配，但随着操作系统的运行时间越久，内存碎片也会越多，为了解决内存碎片无法使用的问题引出了“分段”的概念。

分段的大致思想是：将进程P的在内存划分出多个区域使用，相当于将进程P分离出多个“段（segment）”，每个“段”都塞进对应的内存碎片里，这样能保证内存的使用率。但分段也引出了一个问题：基址与逻辑地址该如何划分？**毕竟现在进程P不是占用一块完整、连续的内存，每一个段都有不同的基址、每一个段的逻辑地址都是才从0开始**。 

![image](https://user-images.githubusercontent.com/48977889/147898274-c16d026a-34e9-4374-8833-8d4320ee93bb.png)

这依赖了一个分段硬件，它有一个段表记录了一个进程的每个段信息、每个段的段基址、段最大偏移量，每一个段都有唯一的段号。进程的逻辑地址表述为<段号,段内逻辑地址（段内位移）>，通过这个二元组来代表该进程在内存唯一的数据。**通常在PC寄存器中逻辑地址以16进制数表示，前n个比特位为段号、后面的比特位为段内位移（不同的操作系统可能有差异）**。

段表：

| 段号 | 段基址（物理地址） | 段限长（逻辑地址长度） |
| :--: | :----------------: | :--------------------: |
|  #1  |         X          |           5            |
|  #2  |         Y          |           4            |
|  #3  |         Z          |           5            |

假设现在CPU从PC寄存区取出<#1,4>来获取指令，步骤如下：

1.根据#1在段表找到段信息，将段限长5放入限长寄存器，将段基址X放入基址寄存器。

2.根据<#1,4>的4与限长寄存器的5进行比较，如果小于则继续，大于则抛出error。

3.在2.继续的基础下，将(基址寄存器的值5)+4获取到指令的物理地址，最终CPU通过物理地址从内存中取出指令（可能会涉及到Cache）。

# 分页

分页是除了分段外的另一种形式，它有点类似固定内存分配。首先在内存**等额划分出大小为n字节的区域**，不同于固定分配的是：进程在内存中的分配不是连续的，也是离散存储在不同的**区域**中，同一个**区域**有且只能被一个进程占用。

这个**区域**被称为“页”，一个页可以被两个属性描述：页号（页码）、页框（帧）。分页的逻辑地址与分段类似，采用**<页号、页内位移>**的形式记录，因此分页和分段面临着相同的问题：到底如何区分基址和偏移量呢？这个时候就用到**页表**

| 页号 | 页框 |
| :--: | :--: |
|      |      |

我们假设内存被划分了多个页，每个页的大小为4byte，进程P占用了三个页：

![219631a7cc63a9b122264528ac8e06f](https://user-images.githubusercontent.com/48977889/147901897-e4f5bc80-72d6-459d-ae4b-d156e93c710c.png)

假设CPU从PC寄存器获取到<#0,2>的逻辑地址，根据以下页表

| 页号 | 页框 |
| :--: | :--: |
|  0   |  5   |
|  1   |  0   |
|  2   |  2   |

查到页框=5，根据页面大小4可以计算出页框5的起始地址= （5 x 4) = 20，这个20即页框5的基址，最后通过基址+偏移量2=22获取到指令的物理地址。

![1641188201(1)](https://user-images.githubusercontent.com/48977889/147902054-6a930cc0-56e6-4360-be02-431e5608aed8.jpg)

分页与分段有点相似，都是基于二元组获取最终的物理地址，**这个二元组都是通过比特位在逻辑地址中划分**，只不过分页还需要页码与页框的转换，但相比于分段来说，分页的寻址速度会更快。现有的操作系统大多数使用分页，也有一部分使用分页+分段结合。

# 页表策略

**页表也是存在内存中**。操作系统会为每一个进程维护一个页表的备份，页表用于将逻辑地址转换为物理地址，页表的内存地址会在进程被CPU调度的时候被加载到**页表基址寄存器**（page-table base register），通过ptbr获取页表的信息，最后使用（获取指令、数据的物理内存地址），也就是说切换页表只需切换cpu的ptbr值即可，因此分页的用时消耗会发生在上下文切换时。

进程被切换到CPU的第一次调度就要访问内存两次：一次拿页表、一次拿数据。虽然会有Cache的存在，但这多拿一次页表仍是一个性能瓶颈，因此引出了一个硬件：TLB，即Translation Look-aside Buffer。

TLB本质是一个缓存，比起内存Cache，TLB是一个特殊、专用的缓存。**它专门用来查询页表**，查找速度很快。TLB只有**一部分进程的一部分页表项**（即页表的一部分），这部分页表项也称为**快表**。当CPU从PC拿到一个逻辑地址时，从前N个比特位获取页号，再通过页号查询TLB获得页框号，如果命中页框号则直接算出物理地址；如果TLB未命中页框号，只能走PTBR这条路了。**如何提高TLB的命中率是一个问题...**

# 多级页表

页是有大小的，如果一个进程P占用了很多页，那么该进程的页表就会有许多个页项；页项作为页表的一部分，页项越多则页表越大，上面说过页表最终还是存放在内存中，如果一个很大的页表存放在内存中则会占用很多连续空间，这就又回到上面说到的连续分配内存带来的问题了。为了不希望页表占用的连续空间太大，提出了页表页的概念。

页表页，即二级页表，它本质也是一种页表，与普通页表不同的是页表页存储的二元组是<页表页号，页框号>，页表页号指的是页表被切分后的序号、页框号指的是页表被切分部分存放在内存里的页框号。

![b180ccea4e9a47ceb70c62b1c10670e](https://user-images.githubusercontent.com/48977889/148240354-3da5462c-3364-418e-a333-45b337e22b76.png)

如上图所示，假设绿色部分是进程P的页表，右边是内存的分页情况，黄色部分是页表页。进程P占用了八个页框，如果这个页表要占用两个框的内存空间的话就要分配两个单位的**连续内存**，在多进程、多内存占用的情况下是不合理的。因此把绿色部分的页表以**四个框**为单位拆分出了两部分：

1.这两部分由上往下分别用**页表页号PPT#0、PPT#1**标记

2.然后分别存储在内存的不同**框**内。

页表页的二元组即上面所说的<1.，2.>，**最终页表页存储到F#5这个框内**。此时逻辑地址与MMU的寻址就发生了如下变化：

![d6530646ae9ab5bb1f182372f801829](https://user-images.githubusercontent.com/48977889/148240370-56d669ac-69d7-440a-bbec-b23253b07c0e.png)

1.先从PTBR获取二级页表的内存地址（即F#5），逻辑地址前N位部分代表页表页号，寻址时在二级页表先根据页表页号查询出页表区域（F#7或F#10）。

2.通过页表区域拿到一级页表（部分），逻辑地址中间部分代表页号，在一级页表通过页号查询出框号。

3.逻辑地址最后部分是页内位移，在框号通过页内位移定位到具体的物理内存地址。

是的，如果采用了二级页表，就会增加一次页表的寻址：**找页表页** → 找页表  → 定位偏移量，这本质是一个开销，但从综合情况下考虑页表页能加快查询性能。

在Linux64位系统下，甚至会有4级页表的出现，具体的寻址过程差不多，也是先找最上层页表，最后逐层逐层往下定位找到一级页表，再通过偏移量算出需要的物理地址，此时逻辑地址的格式就变成这样了：

![a0db41824e4895600c52a7af568727c](https://user-images.githubusercontent.com/48977889/148240381-af537d36-de3b-4602-8a06-90294a1c7352.png)





