# 内存本质（软件层面）

1.内存本质是一个很大的字节数组，每个字节都有它的地址（**物理地址**）。

2.CPU根据PC寄存器的值，从内存中获取下一条要执行指令。**这条指令可能会引发对内存的读写**。

3.一个指令执行周期：CPU从内存获取指令、指令被译码、指令被执行。

# Cache

即高速缓存，Cache是介于内存与CPU中间的一个中间设备，它的存取速度比内存快得多，但容量比内存小得多。要是CPU每次都直接操作内存效率会很慢很多。CPU在读取内存数据时优先读取缓存，如果缓存有则直接取缓存数据，反之则先从内存获取数据，然后备份数据到缓存，等下一次取相同数据时就可以直接从缓存拿了；这一步与Redis-数据库访问基本一致，但也面临着同样的问题：**当发生数据修改时如何保证缓存-内存一致性？ TODO**

现在主流的CPU通常有三级缓存：L1、L2、L3，级别越低越接近CPU，容量越小，速度越快。如下图（4核8线程）：

![caf1303be02a628e97cce6942e84ace](https://user-images.githubusercontent.com/48977889/147805276-fc51cb90-d5a6-45f5-b806-96be5aacf8ef.png)

每一个核心都有独立的L1、L2，多个核心共享一个L3，这也面临着**数据同步问题**。

# 内存分级

用户进程不能随意访问内存区域，也不能直接影响其他进程的内存区域，这条规则操作系统不直接干预，主要是通过两个硬件实现：基址寄存器、限长寄存器。这两个寄存器存在于CPU内，进程对内存的操作只能这两个寄存器限定的范围内。这两个寄存器的值只能通过特权指令设置，最终是通过CPU控制（也就是说有可能会被恶意植入）。

![6e439acaf68d47edf1f9bcea632f59a](https://user-images.githubusercontent.com/48977889/147805645-dfb20dd8-9dd5-4ac5-add8-bd1ce67fa204.png)

# 逻辑地址与物理地址的转换 

现有的操作系统都是在进程运行时通过MMU进行地址转换的，MMU内有一个关键的寄存器：基址寄存器（重定位寄存器），地址转换是通过该寄存器完成的。

![5fd0396d8ff40ee1767581c82a02032](https://user-images.githubusercontent.com/48977889/147868905-d4d6b86e-058b-40dc-8134-81f28f067c15.png)

# 分段与分页

首先要确定，进程在分段与分页之前，首先讲一下内存的固定分区分配与动态分区分配

固定分区分配：内存一开始就被固定分配了若干的分区，每个分区都有其固定的大小，**每个分区有且只能有一个进程**。为进程P分配内存时优先选择最符合进程所需内存的内存分区。

![20066b000618730814f4b0d9f22fdd4](https://user-images.githubusercontent.com/48977889/147876992-4de80ffc-4936-4121-8741-fef0acf89a3e.png)

动态分区分配：没有被分配出去的内存区域成为“孔（hole）”，为进程P分配内存时选择大小合适的孔给进程。初始状态时孔即内存大小，随着内存的分配与释放，孔的数量与大小会不断变化。对于孔的分配有三种策略：1.首次分配：即选择第一个能容纳进程所需内存大小的孔；2.最佳分配：选择一个大小与进程所需内存大小最接近的孔，3.最坏分配：选择最大的孔分配。

![5034b8973c68e9ee01dbdaffd1bb03b](https://user-images.githubusercontent.com/48977889/147876998-c7c650be-9b10-4297-b77b-37f2f6dfc984.png)

对于固定分区分配来说，内存碎片指的是分区内进程无法用到的内存区域（容量-分区 ＞ 容量-进程）。对于动态分区分配来说，内存碎片指的是接下来的一段时间内由于太小而无法分配给进程的孔。

