# 逻辑地址与物理地址

逻辑地址：程序在变成可执行文件后每一条**指令或数据**对应的地址，这个地址并非物理内存上的地址，而是一个虚拟的地址，它可以用来在指令上进行流程控制以及变量取址，比如从A指令跳转到B指令需要知道B指令对应的逻辑地址。逻辑地址最终会被映射为物理地址。每个进程的逻辑地址都从0开始，逻辑地址在同一进程中唯一。**逻辑地址是16进制数**。

物理地址：是指令与数据真实存在的地址，物理地址在同一个内存中唯一，逻辑地址最终通过MMU这个硬件设备转换为物理地址。实际上MMU对物理地址的运算是：**基址（进程起始地址，每次启动都不一样） + 指令逻辑地址**。

# 进程内存映像

以32位机器为例，每一个进程可以获得一个2的32次方Bytes的逻辑地址空间（即4GB），当然实际上不会用得了4G。这个逻辑地址空间会被拆分成内核空间、用户空间。其中用户空间能被分到3GB、内核空间能被分到1GB。**我们所说的进程内存空间实际上都是逻辑地址，是虚拟的。**

![5f91d47a2dd3893c3f2deceb1f0fce5](https://user-images.githubusercontent.com/48977889/147723513-bbe7b38e-05d0-48f6-9933-f8fc9100f314.jpg)



# 查看进程的内存情况

在Linux中，可以通过cat /proc/{进程ID}/maps命令查看该进程ID对应的进程内存分布，每一列的字段含义如下

第一列：内存区域的地址范围（**逻辑地址**）。

第二列：这块内存区域的权限，分别为：r(可读)w(可写)x(可执行)p/s(私有的/共享的)。

第三列：偏移量。

第四列：设备号。

第五列：iNode。

第六列：这块内存关联的文件，也可展示是栈还是堆。

![146d41a320b364d1e435e41eb39ec9a](https://user-images.githubusercontent.com/48977889/147723518-3b0d659a-86c2-4f74-a0be-adc0d82f6652.jpg)